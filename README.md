# Задание 33 — Метод бисекции на RISC‑V (RARS 1.6). Оценка 10/10

**Студент:** Солод Алексей Александрович (БПИ‑248)  

---

## Цель работы

Найти корень уравнения
\[
f(x) = x^3 - \tfrac{1}{2}x^2 + 0.2x - 4 = 0
\]
методом **бисекции** с точностью \(\varepsilon \in [10^{-8}; 10^{-3}]\).  
Базовый интервал — \([1; 3]\). Если пользователь вводит интервал без смены знака (не «бракета»), программа **автоматически подбирает корректный** интервал.

---

## Структура проекта

- `main.asm` — интерактивная программа:
  - чтение `epsilon`, `a`, `b` (ввод раздельно; только числа с точкой/экспонентой);
  - клампинг `epsilon` к `[1e-8; 1e-3]` с уведомлением;
  - проверка бракета через **произведение** `f(a) * f(b) < 0`;
  - при отсутствии бракета — вызов `find_bracket(a,b,&A,&B)`; печать подобранного интервала;
  - запуск `bisect_root(a,b,eps,&iters)`; печать корня, числа итераций и **|f(root)|**;
  - корректное завершение через `ecall 10` (без `ret` из `main`).

- `math_utils.asm` — библиотека подпрограмм (double, ABI, стек):
  - `f_eval(x)` — вычисление полинома;
  - `find_bracket(a,b,&A,&B)` — поиск интервала со сменой знака: скан `[-10; 10]` шагом `0.5` (есть fallback);
  - `bisect_root(a,b,eps,&iters)` — метод бисекции; стоп при `(b-a)/2 ≤ eps` или `iters == 300`.

- `io_macros.inc` — **реальные макросы** (с параметрами в стиле RARS), разворачиваются в вызовы процедур I/O:
  - `PRINT_STR %label`, `READ_DOUBLE %fd`, `PRINT_DOUBLE`, `PRINT_INT`.
  - Используются как в `main.asm`, так и в `test_runner.asm`.

- `test_runner.asm` — автономные **автотесты** (без ввода): 5 кейсов с разными `eps` и интервалами.

**Хранение данных.** В `main.asm` параметры `A`, `B`, `EPS` и значения `FA=f(a)`, `FB=f(b)` — это **память** (по 8 байт). Доступ только через корректную адресацию RARS: `la t3, LABEL` + `fld/fsd 0(t3)`. Это гарантирует, что значения не будут случайно перезаписаны внутренними временными регистрами `f_eval`.

---

## Инструкция по запуску (RARS 1.6)

Рекомендуемые настройки:
- `Settings → Assemble all files in editor` — **ON**
- (если доступно) `Settings → Initialize PC to 'main' if defined` — **ON**

**Интерактивная версия:**
1. Откройте `main.asm`, `math_utils.asm`, `io_macros.inc`.
2. Нажмите **F3** (Assemble), затем **F5** (Run).
3. Вводите **строго числа** (десятичная точка, допускается экспонента):
   - `epsilon`: например `1e-5`
   - `a`: например `1`
   - `b`: например `3`
4. В выводе появится выбранный интервал, корень, число итераций и `|f(root)|` (порядка `eps`).

**Автотесты:**
1. Откройте `test_runner.asm`, `math_utils.asm`, `io_macros.inc`.
2. **F3 → F5**. Пробегаются 5 кейсов, печатаются интервал, `eps`, корень, итерации.

---

## Описание метода

Метод бисекции поддерживает интервал `[a; b]`, в котором `f(a)` и `f(b)` имеют **разные знаки** (бракета). На каждом шаге берётся середина `m=(a+b)/2` и выбирается та половина, где сохраняется смена знака. Остановка: `(b-a)/2 ≤ eps` (или лимит итераций 300). Возвращается середина текущего интервала.

Проверка бракета везде реализована через **произведение** `f(a)*f(b) < 0` — это компактно и надёжно.

---

## Пример сессии

```
Enter epsilon in [1e-3;1e-8]: 1e-5
Enter a (e.g., 1): 1
Enter b (e.g., 3): 3
Using bracket: [1, 3]
Root ~= 1.705496...
  iterations = 50  |f(root)| = ~1e-5
```

(Истинное значение корня ≈ **1.7055**; формат числа зависит от печати double в RARS.)

---

## Тестовое покрытие

`test_runner.asm` содержит 5 кейсов (иллюстрации):
- `[1.0, 3.0]`, `eps = 1e-3`
- `[1.0, 3.0]`, `eps = 1e-5`
- `[1.0, 3.0]`, `eps = 1e-8`
- `[2.0, 2.5]`, `eps = 1e-6`
- `[-10.0, 10.0]`, `eps = 1e-4`

Цели: проверить сходимость при разных точностях, узком и широком интервале, а также устойчивость алгоритма.

---

## Обработка ошибок и устойчивость

- **Ввод:** `a` и `b` запрашиваются **раздельно**, чтобы избежать `invalid double input (syscall 7)` при скобках/запятых и т.п.
- **Точность:** `epsilon` жёстко приводится к `[1e-8; 1e-3]` с сообщением.
- **Бракета:** если интервал не годится, выполняется **автопоиск** в `[-10; 10]` шагом `0.5` (есть fallback).
- **Стоп-критерий:** помимо `(b-a)/2 ≤ eps` стоит предохранитель `iters ≤ 300`.
- **Выход:** завершение через `ecall 10` (без `ret` из `main`), чтобы не было `Instruction load access error`.
- **Совместимость RV32:** везде `sw/lw` (нет `sd/ld`), обычные метки `L_*`, доступ к памяти через `la` + `fld/fsd`.

---

## Почему «10/10»

- **Double‑precision** (RV32I + D) и правильная работа с памятью/адресацией.
- **Модульность:** библиотека подпрограмм (`math_utils.asm`) и **inc‑файл** с реальными макросами (`io_macros.inc`), которые используются в нескольких файлах.
- **Подпрограммы + стек + ABI:** корректные вызовы/сохранения, локальные на стеке, читаемые комментарии.
- **Робастность:** клампинг `epsilon`, проверка бракета через произведение, автопоиск интервала, ограничение итераций, раздельный ввод.
- **Автотесты:** отдельный `test_runner.asm` с несколькими сценариями; воспроизводимость.
- **Документация:** данный README полностью описывает постановку, архитектуру и запуск.

---
